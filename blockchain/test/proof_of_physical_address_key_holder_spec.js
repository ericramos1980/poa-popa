const ProofOfPhysicalAddressKeyHolder = artifacts.require('ProofOfPhysicalAddressKeyHolder');

const signerPublicAddress = web3.eth.accounts[0];
const anotherAddress = web3.eth.accounts[1];
const signerHashedAddress = web3.sha3(signerPublicAddress, { encoding: 'hex' });

contract('ProofOfPhysicalAddressKeyHolder', async () => {

    let contract;

    before(async () => {
        contract = await ProofOfPhysicalAddressKeyHolder.deployed();
    });

    describe('KeyHolder (erc725-only API) implementation', async () => {
        it('should set a default MANAGEMENT_KEY', async () => {
            var res = await contract.getKey(signerHashedAddress);
            // res tuple positions: 0 purpose, 1: type, 2: key
            assert.equal(res[0], '1');
            assert.equal(res[1], '1');
            assert.equal(res[2], signerHashedAddress);
        });

        it('should respond to getKeyPurpose', async () => {
            var res = await contract.getKeyPurpose(signerHashedAddress);
            assert.equal(res, '1');
        });

        it('should respond to getKeysByPurpose', async () => {
            var res = await contract.getKeysByPurpose(1);
            assert.deepEqual(res, [signerHashedAddress]);
        });

        it('should implement addKey', async () => {
            var newKey = web3.sha3('0xOtherAddress', { encoding: 'hex' });
            var res = await contract.addKey(newKey, 1, 1, { from: signerPublicAddress });
            const event = res.logs[0].event;
            const args = res.logs[0].args;
            assert.equal(event, 'KeyAdded');
            assert.equal(args.purpose, '1');
            assert.equal(args.keyType, '1');
            assert.equal(args.key, newKey);

            var getKey = await contract.getKey(newKey);
            assert.equal(getKey[2], newKey);
        });

        it('should not allow an existing key to be added', async () => {
            try {
                await contract.addKey(signerHashedAddress, 1, 1);
                assert(false);
            } catch (e) {
                assert(e.message.match(/revert/));
            }
        });

        it('should not allow sender without MANAGEMENT_KEY to addKey', async () => {
            try {
                var newKey = web3.sha3('0xOtherAddress', { encoding: 'hex' });
                await contract.addKey(newKey, 1, 1, { from: anotherAddress });
                assert(false);
            } catch (e) {
                assert(e.message.match(/revert/));
            }
        });

        // This will be the case when verifying erc735 claims generated by PoPA
        it('should return true when keyHasPurpose is called with the signer key and purpose "3" (CLAIM)', async () => {
            const res = await contract.keyHasPurpose(signerHashedAddress, 3);
            assert.equal(res , true);
        });
    });

});
