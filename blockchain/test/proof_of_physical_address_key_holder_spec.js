const ProofOfPhysicalAddressKeyHolder = artifacts.require('ProofOfPhysicalAddressKeyHolder');

const signerPublicAddress = web3.eth.accounts[0];
const anotherAddress = web3.eth.accounts[1];
const signerHashedAddress = web3.sha3(signerPublicAddress, { encoding: 'hex' });

contract('ProofOfPhysicalAddressKeyHolder', async () => {

    let contract;

    before(async () => {
        contract = await ProofOfPhysicalAddressKeyHolder.deployed();
    });

    describe('KeyHolder (erc725-only API) implementation', async () => {
        it('should set a default MANAGEMENT_KEY', async () => {
            var res = await contract.getKey(signerHashedAddress);
            // res tuple positions: 0 purpose, 1: type, 2: key
            assert.equal(res[0], '1');
            assert.equal(res[1], '1');
            assert.equal(res[2], signerHashedAddress);
        });

        it('should respond to getKeyPurpose', async () => {
            var res = await contract.getKeyPurpose(signerHashedAddress);
            assert.equal(res, '1');
        });

        it('should respond to getKeysByPurpose', async () => {
            var res = await contract.getKeysByPurpose(1);
            assert.deepEqual(res, [signerHashedAddress]);
        });

        it('should implement addKey', async () => {
            var newKey = web3.sha3('0xOtherAddress', { encoding: 'hex' });
            var res = await contract.addKey(newKey, 1, 1, { from: signerPublicAddress });
            const event = res.logs[0].event;
            const args = res.logs[0].args;
            assert.equal(event, 'KeyAdded');
            assert.equal(args.purpose, '1');
            assert.equal(args.keyType, '1');
            assert.equal(args.key, newKey);

            var getKey = await contract.getKey(newKey);
            assert.equal(getKey[2], newKey);
        });

        it('should implement removeKey', async () => {
            var newKey = web3.sha3('0xRemoveKeyTest', { encoding: 'hex' });
            await contract.addKey(newKey, 1, 1, { from: signerPublicAddress });
            var res = await contract.removeKey(newKey);
            const event = res.logs[0].event;
            const args = res.logs[0].args;
            assert.equal(event, 'KeyRemoved');
            assert.equal(args.purpose, '1');
            assert.equal(args.keyType, '1');
            assert.equal(args.key, newKey);
        });

        it('should not allow an existing key to be added', async () => {
            try {
                await contract.addKey(signerHashedAddress, 1, 1);
                assert(false);
            } catch (e) {
                assert(e.message.match(/revert/));
            }
        });

        it('should not allow sender without MANAGEMENT_KEY to addKey', async () => {
            try {
                var newKey = web3.sha3('0xOtherAddress', { encoding: 'hex' });
                await contract.addKey(newKey, 1, 1, { from: anotherAddress });
                assert(false);
            } catch (e) {
                assert(e.message.match(/revert/));
            }
        });

        it('should fail to removeKey that doesn\'t exist', async () => {
            try {
                var newKey = web3.sha3('0xInexistentThing', { encoding: 'hex' });
                await contract.removeKey(newKey);
                assert(false);
            } catch (e) {
                assert(e.message.match(/revert/));
            }
        });

        it('should not allow sender without MANAGEMENT_KEY to removeKey', async () => {
            try {
                await contract.removeKey(signerHashedAddress, { from: anotherAddress });
                assert(false);
            } catch (e) {
                assert(e.message.match(/revert/));
            }
        });

        // This will be the case when verifying erc735 claims generated by PoPA
        it('should return true when keyHasPurpose is called with the signer key and purpose "3" (CLAIM)', async () => {
            const res = await contract.keyHasPurpose(signerHashedAddress, 3);
            assert.equal(res , true);
        });


    });

    describe('signer management', async () => {
        it('signer should be equal to owner', async () => {
            const owner = await contract.owner();
            const signer = await contract.signer();
            assert.equal(owner, signer);
        });

        it('should allow the owner to change the signer', async () => {
            const signerBefore = await contract.signer();
            await contract.setSigner(web3.eth.accounts[1]);
            const signerAfter= await contract.signer();
            assert.notEqual(signerBefore, signerAfter);
            assert.equal(web3.eth.accounts[1], signerAfter);
        });

        it('should not allow someone that\'s not the owner to change the signer', async () => {
            const signerBefore = await contract.signer();
            await contract.setSigner(web3.eth.accounts[2], { from: web3.eth.accounts[1] })
                .then(
                    () => assert.fail(),
                    async () => {
                        const signerAfter= await contract.signer();
                        assert.equal(signerBefore, signerAfter);
                    }
                );
        });
    });

});
